---
title: "20241014_workflow_scRNAseq"
output: html_document
date: "2024-10-14"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## [0.] Prerequisites -------------------------

## [-1.0.] Avoid gcc compiler problems
```{r}
base::Sys.setenv(
  PATH = base::paste(
      "/opt/software/gcc/11.2.0/bin",
      base::Sys.getenv("PATH"),
      sep = ":"
    )
  )
base::Sys.setenv(
    CXX = "/opt/software/gcc/11.2.0/bin/g++"
  )
```

## [-1.1.] Install necessary packages
#### Missing packages: libtiff-4, lubridate, systemfonts
```{r eval=FALSE}
utils::install.packages("here")
utils::install.packages("assertthat")

utils::install.packages("ape") # used for BuildClusterTree in [3.5.]
utils::install.packages("tidygraph")
utils::install.packages("ggraph")
utils::install.packages("clustree") # used in [3.6.]

# utils::install.packages("tidyverse")
```

## [-1.2.] Check version of packages
```{r eval=FALSE}
utils::packageVersion("Seurat")
```

## [0.0.] Load necessary packages
```{r message=FALSE}
base::library("Seurat")
base::library("tidyverse")
```

## [1.] Read in & preprocess data -------------------------

## [1.0.] Check that directory exists
```{r}
dir <- base::paste0(
    here::here("input_data/"),
    "raw_feature_bc_matrix/"
  )
base::dir.exists(paths = dir)
```

## [1.1.] Read in data as sparse matrices
#### Data read in as dgCMatrices
```{r}
pbmc_data <- Seurat::Read10X(
    data.dir = dir,
    gene.column = 2, # column specifying gene names in features.tsv.gz
    cell.colum = 1 # column specifying the cell ID in barcodes.tsv.gz
  )
```

## [1.2.] Inspect data & calculate sparsity
#### See https://slowkow.com/notes/sparse-matrix/ for more info on how to access data in dgCMatrices
#### Sparse data most optimally saved in dgCMatrices
```{r}
utils::str(pbmc_data)
pbmc_data$`Gene Expression`[1:5,1:5]
base::dim(pbmc_data$`Gene Expression`)
100 - (base::length(pbmc_data$`Gene Expression`@x) / base::prod(pbmc_data$`Gene Expression`@Dim))*100 # Sparsity
```

## [1.3.] Create a Seurat object from the scRNAseq data
#### Seurat objects are S3 object-oriented objects, see https://adv-r.hadley.nz/s3.html
```{r}
pbmc_rna <- Seurat::CreateSeuratObject(
    counts = pbmc_data$`Gene Expression`, ## Specify scRNAseq
    assay = "RNA",
    project = "pbmc",
    min.cells = 3, # minimal amount of cells expressing a feature
    min.features = 200 # minimal amount of features detected per cell
  )
```

#### Alternatively create a Seurat object from both matrices
```{r eval=FALSE}
# pbmc_multi <- Seurat::CreateSeuratObject(
#     counts = pbmc_data,
#     assay = "Multi",
#     project = "pbmc",
#     min.cells = 3, # minimal amount of cells expressing a feature
#     min.features = 200 # minimal amount of features detected per cell
#   )
# utils::str(pbmc_multi)
```

## [1.4.] Inspect the Seurat object
#### Filtering in [1.3.] reduced the number of rows and columns
#### dimensions: 26315 10987; sparsity: 94.39873
```{r}
utils::str(pbmc_rna)
base::dim(pbmc_rna) # base::dim(pbmc_rna@assays$RNA@layers$counts) 
pbmc_rna@assays$RNA@layers$counts[1:5,1:5]
100 - (base::length(pbmc_rna@assays$RNA@layers$counts@x) / base::prod(pbmc_rna@assays$RNA@layers$counts@Dim))*100 # Sparsity
```

## [1.5.] Detect & count mitochondrial gene contribution
#### On terminal:  gunzip -c features.tsv.gz | cut -f2 | grep '^MT-' | head
```{r}
## base::dimnames(pbmc_rna@assays$RNA@features@.Data)[[1]]
feat_names <- base::rownames(pbmc_rna) ## base::colnames(pbmc_rna)
feat_names[base::grep("^MT-",feat_names)]
  
pbmc_rna[["percent.mt"]] <- Seurat::PercentageFeatureSet(
    object = pbmc_rna,
    pattern = "^MT-"
  )
```

## [1.6.] Inspect & visualize features, including mitochondrial gene contribution
```{r}
pbmc_rna@meta.data # Inspect new variable
base::colnames(pbmc_rna[[]])

Seurat::VlnPlot(
    object = pbmc_rna,
    features = base::colnames(pbmc_rna[[]])[2:4],
    ncol = 3
  )
base::mean(pbmc_rna@meta.data$percent.mt)

Seurat::FeatureScatter(
      object = pbmc_rna,
      feature1 = "nCount_RNA",
      feature2 = "percent.mt"
    ) +
  geom_density2d() +
  geom_hline(
      yintercept = base::c(5,10),
      linetype = "dashed"
    )

Seurat::FeatureScatter(
      object = pbmc_rna,
      feature1 = "nCount_RNA",
      feature2 = "nFeature_RNA"
    ) +
  geom_density2d() +
  geom_hline(
      yintercept = base::c(200L,2500L),
      linetype = "dashed"
    )
```

## [1.7.] Filter cells
#### Based on inspection in [1.6.]
#### Removes empty droplets, droplets with â‰¥ 2 cells, apoptotic cells or cells with insufficiently captured transcripts
#### dimensions: 26315 7573; sparsity: 94.87731
```{r}
pbmc_rna <- base::subset(
    x = pbmc_rna,
    subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 10
  )
base::dim(pbmc_rna)
100 - (base::length(pbmc_rna@assays$RNA@layers$counts@x) / base::prod(pbmc_rna@assays$RNA@layers$counts@Dim))*100 # Sparsity
```

# [2.] Process data - Normalize, scale, reduce dimensions -------------------------

## [2.0.] Normalization
```{r}
pbmc_rna <- Seurat::NormalizeData(
    object = pbmc_rna,
    normalization.method = "LogNormalize",
    scale.factor = 1e+4,
    verbose = FALSE
  )
```

## [2.1.] Inspect normalized data
```{r}
utils::str(pbmc_rna)
pbmc_rna@assays$RNA@layers$data
pbmc_rna[["RNA"]]$data
```

##<<boomark/SCTransform()>>

## [2.2.] Find most highly variably expressed genes
#### Identification of features (genes) with highest variability across all cells to apply variance-stabilizing data transformation 
```{r}
pbmc_rna <- Seurat::FindVariableFeatures(
    object = pbmc_rna,
    selection.method = "vst",
    nfeatures = 2000L,
    verbose = FALSE
  )
```

## [2.3.] Inspect variable genes
```{r}
utils::str(pbmc_rna)
pbmc_rna@assays$RNA@meta.data
  
lbls <- Seurat::VariableFeatures(object = pbmc_rna)[1:10]
raw <- Seurat::VariableFeaturePlot(
    object = pbmc_rna
  )
Seurat::LabelPoints(
      plot = raw,
      points = lbls,
      repel = TRUE
    ) +
  geom_density2d() +
  geom_hline(
      yintercept = 1.25,
      linetype = "dashed"
    )
```

## [2.4.] Scale across dataset
#### Linear transformation for each feature (gene) across the variable genes to prepare principal component analysis (PCA)
#### Scale across all genes as default is to perform scaling only on the variable features
```{r}
pbmc_rna <- Seurat::ScaleData(
    object = pbmc_rna,
    features = base::rownames(pbmc_rna),
    verbose = FALSE
  )
```

#### Alternative is to use scaling for removal of potential sources of variation, e.g., mitochondrial reads or cell cycle phase
```{r}
# pbmc_rna <- Seurat::ScaleData(
#     object = pbmc_rna,
#     vars.to.regress = "percent.mt"
#   )
```

## [2.5.] Run principal component analysis
#### RunPCA when called on a Seurat objects operates on the scale.data slot of the assay by default
#### Seurat:::PrepDR5() function prepares internally the data to be used for PCA
```{r}
Seurat::DefaultAssay(object = pbmc_rna)
SeuratObject::Layers(object = pbmc_rna)
SeuratObject::LayerData(object = pbmc_rna, layer = "scale.data")[1:10,1:10]

pbmc_rna <- Seurat::RunPCA(
    object = pbmc_rna,
    features = Seurat::VariableFeatures(object = pbmc_rna),
    npcs = 50L,
    verbose = FALSE,
    seed.use = 1L,
    assay = "RNA", #default at this stage
    layer = 'scale.data' # default
  )
```

## [2.6.] Inspect PCA results
```{r}
utils::str(pbmc_rna)
pbmc_rna[["pca"]]
pbmc_rna@reductions$pca@feature.loadings

base::print(
    pbmc_rna[["pca"]],
    dims = 1:3,
    nfeatures = 10
  )
Seurat::VizDimLoadings(
    object = pbmc_rna,
    dims = 1:3,
    reduction = "pca",
    ncol = 3,
    nfeatures = 10
  )
Seurat::DimPlot(
      object = pbmc_rna,
      reduction = "pca",
      dims = 1:2
    ) +
  theme_bw() +
  theme(
      legend.position = "none",
      aspect.ratio = 1
    )
```

## [2.7.] Inspect dimensionality of the data
```{r}
Seurat::DimHeatmap(
    object = pbmc_rna,
    dims = 1:15,
    cells = 500, # top 500 cells
    balanced = TRUE,
    nfeatures = 10,
    slot = "scale.data"
  )

Seurat::ElbowPlot(
      object = pbmc_rna,
      ndims = 50,
      reduction = "pca"
    ) +
  geom_hline(
      yintercept = 1.3,
      linetype = "dashed"
    ) +
  geom_vline(
      xintercept = base::c(5,10),
      linetype = "dashed"
    )
```

#### Resampling method using JackStraw
#### Time consuming approach
```{r}
# pbmc_rna_ <- Seurat::JackStraw(
#     object = pbmc_rna,
#     dims = 50,
#     num.replicate = 100
#   )
# pbmc_rna_ <- Seurat::ScoreJackStraw(
#     object = pbmc_rna_,
#     dims = 1:50,
#     score.thresh = 1e-05
#   )
# Seurat::JackStrawPlot(
#     object = pbmc_rna_,
#     dims = 1:50
#   )
```

# [3.] Cell clustering -------------------------
#### Seurat performs clustering based on PCA scores of features (genes) in cells
#### Choice of included PCAs based on resampling test and Elbow plots

## [3.0.] Calculate nearest neighbors and corresponding graph
#### k-NN graph calculation based on cell distances in PCA latent space
#### refinement of graph edges based on similarity between neighborhoods
#### Uses RcppAnnoy::AnnoyEuclidean, RANN::nn2 (NNHelper) and for calculating
#### the shared nearest neighbour graph SNN_SmallestNonzero_Dist imnplemented via Rcpp (ComputeSNN)
```{r}
Seurat::DefaultAssay(object = pbmc_rna) # assay: "RNA"
SeuratObject::Embeddings(object = pbmc_rna[["pca"]]) # data.use: cell x PCA

pbmc_rna <- Seurat::FindNeighbors(
    object = pbmc_rna,
    dims = 1:10,
    k.param = 20, # default
    verbose = FALSE,
    l2.norm = FALSE
  )
```

## [3.1.] Inspect graph
```{r}
utils::str(pbmc_rna)
pbmc_rna@graphs
```

## [3.2.] Find clusters
#### Louvain or SLM algorithms to iteratively form groups of cells
#### with granularity of result adjusting the amount of identified clusters
```{r}
pbmc_rna <- Seurat::FindClusters(
    object = pbmc_rna,
    resolution = 0.3, # <---- granularity parameter
    verbose = FALSE
  )
```

## [3.3.] Perform non-linear dimension reduction
```{r warning=FALSE}
pbmc_rna <- Seurat::RunUMAP(
    object = pbmc_rna,
    umap.method = "uwot",
    dims = 1:10,
    verbose = FALSE
  )
```

## [3.4.] Visualize UMAP dimension reduction
#### UMAP preserves the local distances in favor of global relationships
```{r}
Seurat::DimPlot(
      object = pbmc_rna,
      reduction = "umap"
    ) +
  theme_bw() +
  theme(
    aspect.ratio = 1
  )
```

## [3.5.] Calculate cluster dendogram
```{r}
pbmc_rna_ <- pbmc_rna
pbmc_rna_ <- Seurat::BuildClusterTree(
    object = pbmc_rna,
    assay = "RNA",
    features = base::rownames(pbmc_rna),
    dims = 1:10,
    reduction = "pca",
    slot = "scale.data",
    verbose = FALSE
  )
utils::str(pbmc_rna_)

# replaces Seurat::PlotClusterTree
data.tree <- SeuratObject::Tool(
    object = pbmc_rna_,
    slot = "Seurat::BuildClusterTree"
  )
ape::plot.phylo(x = data.tree, direction = "downwards")
ape::nodelabels()
```

##<<bookmark/under_construction>> -------------------------

## [3.6.] Evaluate cluster number as a function of cluster granularity / resolution
```{r}
pbmc_rna_ <- pbmc_rna
for(r in base::seq(0.1,1.2,0.1)){
  pbmc_rna_ <- Seurat::FindClusters(
      object = pbmc_rna_,
      resolution = r,
      verbose = FALSE
    )
}
pbmc_rna_@meta.data
base::debugonce(clustree::clustree)
clustree::clustree(
    x = pbmc_rna_,
    prefix = "RNA_snn_res.",
   return = "layout"
  )
```

```{r}
base::colnames(pbmc_rna_[[]])
pbmc_rna@meta.data %>%
  dplyr::

function(x, prefix, suffix = NULL, metadata = NULL, count_filter = 0, 
  prop_filter = 0.1, layout = c("tree", "sugiyama"), use_core_edges = TRUE, 
  highlight_core = FALSE, node_colour = prefix, node_colour_aggr = NULL, 
  node_size = "size", node_size_aggr = NULL, node_size_range = c(4, 
    15), node_alpha = 1, node_alpha_aggr = NULL, node_text_size = 3, 
  scale_node_text = FALSE, node_text_colour = "black", node_text_angle = 0, 
  node_label = NULL, node_label_aggr = NULL, node_label_size = 3, 
  node_label_nudge = -0.2, edge_width = 1.5, edge_arrow = TRUE, 
  edge_arrow_ends = c("last", "first", "both"), show_axis = FALSE, 
  return = c("plot", "graph", "layout"), ...)
```

```{r}
checkmate::assert_matrix(x, any.missing = FALSE, col.names = "unique", 
    min.cols = 2)
  checkmate::assert_character(prefix, any.missing = FALSE, 
    len = 1)
  checkmate::assert_character(suffix, any.missing = FALSE, 
    len = 1, null.ok = TRUE)
  checkmate::assert_number(count_filter, lower = 0, upper = nrow(x))
  checkmate::assert_number(prop_filter, lower = 0, upper = 1)
  checkmate::assert_data_frame(metadata, nrows = nrow(x), 
    col.names = "unique", null.ok = TRUE)
  assert_colour_node_aes("node_colour", prefix, metadata, 
    node_colour, node_colour_aggr)
  assert_numeric_node_aes("node_size", prefix, metadata, node_size, 
    node_size_aggr, 0, Inf)
  assert_numeric_node_aes("node_alpha", prefix, metadata, 
    node_alpha, node_alpha_aggr, 0, 1)
  checkmate::assert_number(node_text_size, lower = 0)
  if (!is.null(node_label)) {
    assert_node_aes("node_label", prefix, metadata, node_label, 
      node_label_aggr)
  }
  checkmate::assert_number(node_label_nudge)
  checkmate::assert_logical(scale_node_text, any.missing = FALSE, 
    len = 1)
  checkmate::assert_number(edge_width, lower = 0)
  checkmate::assert_logical(edge_arrow, any.missing = FALSE, 
    len = 1)
  layout <- match.arg(layout)
  checkmate::assert_flag(use_core_edges)
  return <- match.arg(return)
  edge_arrow_ends <- match.arg(edge_arrow_ends)
  checkmate::assert_flag(highlight_core)
  if (!is.null(suffix)) {
    colnames(x) <- gsub(suffix, "", colnames(x))
  }
  res_clean <- gsub(prefix, "", colnames(x))
  is_num <- suppressWarnings(!any(is.na(as.numeric(res_clean))))
  if (!is_num) {
    stop("The X portion of your clustering column names could not be ", 
      "converted to a number. Please check that your prefix and suffix ", 
      "are correct: prefix = '", prefix, "', suffix = '", 
      suffix, "'", call. = FALSE)
  }
  res_order <- order(as.numeric(res_clean))
  x <- x[, res_order]
  res_clean <- res_clean[res_order]
  if (!(is.null(metadata))) {
    metadata_names <- make.names(colnames(metadata))
    metadata_diff <- metadata_names != colnames(metadata)
    if (any(metadata_diff)) {
      warning("The following metadata column names will be converted from:\n", 
        paste(colnames(metadata)[metadata_diff], collapse = ", "), 
        "\n", "to:\n", paste(metadata_names[metadata_diff], 
          collapse = ", "), call. = FALSE)
      colnames(metadata) <- metadata_names
    }
  }
  node_aes_list <- list(colour = list(value = node_colour, 
    aggr = node_colour_aggr), size = list(value = node_size, 
    aggr = node_size_aggr), alpha = list(value = node_alpha, 
    aggr = node_alpha_aggr))
  if (!is.null(node_label)) {
    node_aes_list$label <- list(value = node_label, aggr = node_label_aggr)
  }
  node_aes_list <- check_node_aes_list(node_aes_list)
  graph <- build_tree_graph(x, prefix, count_filter, prop_filter, 
    metadata, node_aes_list)
  graph_attr <- igraph::graph_attr(graph)
  graph <- graph %>% tidygraph::activate("edges") %>% tidygraph::mutate(width = edge_width) %>% 
    tidygraph::group_by(.data$to) %>% tidygraph::mutate(is_core = .data$in_prop == 
    max(.data$in_prop)) %>% tidygraph::ungroup()
  if (use_core_edges) {
    layout <- graph %>% tidygraph::activate("edges") %>% 
      tidygraph::filter(.data$is_core) %>% ggraph::create_layout(layout)
    attributes(layout)$graph <- graph
  }
  else {
    layout <- ggraph::create_layout(graph, layout)
  }
  gg <- ggraph(layout)
  if (edge_arrow) {
    if (is.numeric(node_size)) {
      circle_size_end <- ifelse(edge_arrow_ends == "first", 
        0.1, node_size * 1.5)
      circle_size_start <- ifelse(edge_arrow_ends == "last", 
        0.1, node_size * 1.5)
    }
    else {
      circle_size_end <- ifelse(edge_arrow_ends == "first", 
        0.1, mean(node_size_range) * 1.5)
      circle_size_start <- ifelse(edge_arrow_ends == "last", 
        0.1, mean(node_size_range) * 1.5)
    }
    gg <- gg + geom_edge_link(arrow = arrow(length = unit(edge_width * 
      5, "points"), ends = edge_arrow_ends), end_cap = circle(circle_size_end, 
      "points"), start_cap = circle(circle_size_start, 
      "points"), aes(colour = .data$count, alpha = .data$in_prop, 
      edge_width = .data$is_core))
  }
  else {
    gg <- gg + geom_edge_link(aes(colour = .data$count, 
      alpha = .data$in_prop, edge_width = .data$is_core))
  }
  if (highlight_core) {
    core_width <- edge_width * 2
    gg <- gg + scale_edge_width_manual(values = c(edge_width, 
      core_width))
  }
  else {
    gg <- gg + scale_edge_width_manual(values = c(edge_width, 
      edge_width), guide = "none")
  }
  gg <- gg + scale_edge_colour_gradientn(colours = viridis::viridis(256)) + 
    scale_edge_alpha(limits = c(0, 1))
  gg <- gg + add_node_points(graph_attr$node_colour, graph_attr$node_size, 
    graph_attr$node_alpha, names(igraph::vertex_attr(graph)))
  if (scale_node_text && !is.numeric(node_size)) {
    gg <- gg + geom_node_text(aes(label = .data$cluster, 
      size = .data[[graph_attr$node_size]]), colour = node_text_colour, 
      angle = node_text_angle)
  }
  else {
    gg <- gg + geom_node_text(aes(label = .data$cluster), 
      size = node_text_size, colour = node_text_colour, 
      angle = node_text_angle)
  }
  if (!(is.null(node_label))) {
    gg <- gg + add_node_labels(graph_attr$node_label, graph_attr$node_colour, 
      node_label_size, node_text_colour, node_label_nudge, 
      names(igraph::vertex_attr(graph)))
  }
  gg <- gg + scale_size(range = node_size_range) + ggraph::theme_graph(base_family = "", 
    plot_margin = ggplot2::margin(2, 2, 2, 2))
  if (show_axis) {
    gg <- gg + ylab(prefix) + scale_y_continuous(breaks = sort(unique(layout$y)), 
      labels = rev(res_clean)) + theme(axis.text.y = element_text(), 
      axis.title = element_text(), axis.title.x = element_blank(), 
      panel.grid.major.y = element_line(colour = "grey92"))
  }
  if (return == "plot") {
    return(gg)
  }
  else if (return == "graph") {
    return(graph)
  }
  else if (return == "layout") {
    return(layout)
```

##<<bookmark/under_construction>> -------------------------

# [4.] Additional analysis & quality checks -------------------------

## [4.0.] Subsample number of cells in initial scRNAseq features x cells matrix
#### 100,000 instead of 733,612 input cells
```{r}
base::set.seed(1)
sub = 1e+5
cols <- base::sample(
    x = 1:base::ncol(pbmc_data$`Gene Expression`),
    size = sub,
    replace = FALSE
  )
pbmc_alt_data <- pbmc_data$`Gene Expression`[,cols]
```

## [4.1.] Run analysis with subsampled cells
#### No parameters changed comapred to [1.3.] - [3.4.]
```{r}
base::set.seed(1)
pbmc_alt <- Seurat::CreateSeuratObject(
    counts = pbmc_alt_data,
    assay = "RNA",
    project = "pbmc10k",
    min.cells = 3,
    min.features = 200
  )
pbmc_alt[["percent.mt"]] <- Seurat::PercentageFeatureSet(
    object = pbmc_alt,
    pattern = "^MT-"
  )
pbmc_alt <- base::subset(
    x = pbmc_alt,
    subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 10
  )
pbmc_alt <- Seurat::NormalizeData(
    object = pbmc_alt,
    normalization.method = "LogNormalize",
    scale.factor = 1e+4,
    verbose = FALSE
  )
pbmc_alt <- Seurat::FindVariableFeatures(
    object = pbmc_alt,
    selection.method = "vst",
    nfeatures = 2000L,
    verbose = FALSE
  )
pbmc_alt <- Seurat::ScaleData(
    object = pbmc_alt,
    features = base::rownames(pbmc_alt),
    verbose = FALSE
  )
pbmc_alt <- Seurat::RunPCA(
    object = pbmc_alt,
    features = Seurat::VariableFeatures(object = pbmc_alt),
    npcs = 50L,
    verbose = FALSE,
    seed.use = 1L,
    assay = "RNA", #default at this stage
    layer = 'scale.data' # default
  )
pbmc_alt <- Seurat::FindNeighbors(
    object = pbmc_alt,
    dims = 1:10,
    k.param = 20, # default
    verbose = FALSE,
    l2.norm = FALSE
  )
pbmc_alt <- Seurat::FindClusters(
    object = pbmc_alt,
    resolution = 0.5,
    verbose = FALSE
  )
pbmc_alt <- Seurat::RunUMAP(
    object = pbmc_alt,
    umap.method = "uwot",
    dims = 1:10,
    verbose = FALSE
  )
Seurat::DimPlot(
      object = pbmc_alt,
      reduction = "umap"
    ) +
  theme_bw() +
  theme(
      aspect.ratio = 1
    )
base::remove(pbmc_alt,pbmc_alt_data)
```

## [4.2.] Subsample reads in gene expression matrix
#### From 38.067.789 to 10.000.000
```{r}
base::set.seed(1)
fin = 1e+7
mat <- pbmc_data$`Gene Expression`
cur <- base::sum(mat@x)
rmv <- cur - fin
smp <- base::sample(
    x = base::sum(mat@x),
    size = rmv,
    replace = FALSE
  )
pos <- base::cumsum(mat@x)
t <- base::table(
    base::findInterval(
      x = smp,
      vec = pos,
      rightmost.closed = FALSE,
      left.open = TRUE
    ) + 1
  )
r <- base::as.numeric(t)
base::names(r) <- base::names(t)
t <- r
n <- t[base::match(base::as.character(1:base::length(mat@x)), base::names(t))]
n[base::is.na(n)] <- 0
mat@x <- mat@x - n # remove sampled reads
pbmc_alt_data <- Matrix::drop0(mat) # drop new 0s
base::sum(pbmc_alt_data@x)
base::remove(r,t,mat,cur,rmv,smp,pos,n)
```

## [4.3.] Run analysis with subsampled reads
#### No parameters changed comapred to [1.3.] - [3.4.]
```{r}
pbmc_alt <- Seurat::CreateSeuratObject(
    counts = pbmc_alt_data,
    assay = "RNA",
    project = "reads10mio",
    min.cells = 3,
    min.features = 200
  )
pbmc_alt[["percent.mt"]] <- Seurat::PercentageFeatureSet(
    object = pbmc_alt,
    pattern = "^MT-"
  )
pbmc_alt <- base::subset(
    x = pbmc_alt,
    subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 10
  )
pbmc_alt <- Seurat::NormalizeData(
    object = pbmc_alt,
    normalization.method = "LogNormalize",
    scale.factor = 1e+4,
    verbose = FALSE
  )
pbmc_alt <- Seurat::FindVariableFeatures(
    object = pbmc_alt,
    selection.method = "vst",
    nfeatures = 2000L,
    verbose = FALSE
  )
pbmc_alt <- Seurat::ScaleData(
    object = pbmc_alt,
    features = base::rownames(pbmc_alt),
    verbose = FALSE
  )
pbmc_alt <- Seurat::RunPCA(
    object = pbmc_alt,
    features = Seurat::VariableFeatures(object = pbmc_alt),
    npcs = 50L,
    verbose = FALSE,
    seed.use = 1L,
    assay = "RNA", #default at this stage
    layer = 'scale.data' # default
  )
pbmc_alt <- Seurat::FindNeighbors(
    object = pbmc_alt,
    dims = 1:10,
    k.param = 20, # default
    verbose = FALSE,
    l2.norm = FALSE
  )
pbmc_alt <- Seurat::FindClusters(
    object = pbmc_alt,
    resolution = 0.5,
    verbose = FALSE
  )
pbmc_alt <- Seurat::RunUMAP(
    object = pbmc_alt,
    umap.method = "uwot",
    dims = 1:10,
    verbose = FALSE
  )
Seurat::DimPlot(
      object = pbmc_alt,
      reduction = "umap"
    ) +
  theme_bw() +
  theme(
    aspect.ratio = 1
  )
# base::remove(pbmc_alt,pbmc_alt_data)
```
```

## [4.4.] Read out metainfo & UMAP data
```{r}
assertthat::are_equal(
    x = base::rownames(pbmc_rna@meta.data),
    y = base::rownames(pbmc_rna@reductions$umap@cell.embeddings)
  )

meta <- pbmc_rna@meta.data %>%
  tibble::as_tibble(rownames = "cell")
umap <- pbmc_rna@reductions$umap@cell.embeddings %>%
  tibble::as_tibble(rownames = "cell")

meta_comb <- dplyr::left_join(
    x = umap,
    y = meta,
    by = "cell"
  )
```

## [4.5.] Average mean cluster positions for cluster labels
```{r}
cls <- meta_comb %>%
  dplyr::group_by(seurat_clusters) %>%
  dplyr::summarise(
      pos_1 = base::mean(umap_1),
      pos_2 = base::mean(umap_2),
      .groups = "drop"
    )
```

## [4.6.] Map quality metrics onto UMAP
```{r}
coef = 0.5
cols <- base::c(
    grDevices::colorRampPalette(
        base::c("#e7f0fa", "#c9e2f6", "#95cbee", "#0099dc", "#4ab04a", "#ffd73e")
      )(coef*100),
    grDevices::colorRampPalette(
      base::c("#eec73a", "#e29421", "#e29421", "#f05336","#ce472e"),
      bias=2
    )((1-coef)*100)
  )

ggplot2::ggplot(
      data = meta_comb,
      mapping = aes(
        x = umap_1,
        y = umap_2,
        color = nFeature_RNA # percent.mt # nCount_RNA, 
      )
    ) +
    geom_point(
      size = 0.1
    ) +
  ggrepel::geom_label_repel(
      inherit.aes = FALSE,
      data = cls,
      mapping = aes(
          x = pos_1,
          y = pos_2,
          label = seurat_clusters
        )
    ) +
  scale_colour_gradientn(
      colours = cols
    ) +
  theme_bw() +
  theme(
      aspect.ratio = 1,
      axis.text = element_blank(),
      axis.ticks = element_blank()
    ) +
  guides(
    fill = "none",
    colour = guide_colourbar(
        label.position = "right",
        title = NULL,
        title.position = "left",
        title.theme = element_text(
            angle = 90,
            hjust = 0.5
          ),
        ticks = T,
        nbin = 100,
        barheight = 8,
        label = T,
        barwidth = 0.5
      )
    )
```

## [4.7.] Cluster-specific quality metrics
```{r}
ggplot2::ggplot(
      data = meta_comb,
      mapping = aes(
        x = seurat_clusters,
        y = nFeature_RNA # percent.mt # nCount_RNA
      )
    ) +
  geom_jitter(
      alpha = 0.1,
      height = 0,
      width = 0.3
    ) +
  geom_boxplot(
      outliers = FALSE,
      alpha = 0.5
    ) +
  geom_hline(
      yintercept = 750L,
      linetype = "dashed"
    ) +
  theme_bw() +
  theme(
      aspect.ratio = 2
    )
```

## [4.8.] Run analysis without removing mitoochondrial contaminations
#### No parameters changed comapred to [1.3.] - [3.4.]
#### Elbow plot looks very similar to pbmc_rna
```{r}
base::set.seed(1)
pbmc_qc <- Seurat::CreateSeuratObject(
    counts = pbmc_data$`Gene Expression`,
    assay = "RNA",
    project = "pbmc10k",
    min.cells = 3,
    min.features = 200
  )
pbmc_qc[["percent.mt"]] <- Seurat::PercentageFeatureSet(
    object = pbmc_qc,
    pattern = "^MT-"
  )
pbmc_qc <- base::subset(
    x = pbmc_qc,
    subset = nFeature_RNA > 750 & nFeature_RNA < 2500 & percent.mt < 10
  )
pbmc_qc <- Seurat::NormalizeData(
    object = pbmc_qc,
    normalization.method = "LogNormalize",
    scale.factor = 1e+4,
    verbose = FALSE
  )
pbmc_qc <- Seurat::FindVariableFeatures(
    object = pbmc_qc,
    selection.method = "vst",
    nfeatures = 2000L,
    verbose = FALSE
  )
pbmc_qc <- Seurat::ScaleData(
    object = pbmc_qc,
    features = base::rownames(pbmc_alt),
    verbose = FALSE
  )
pbmc_qc <- Seurat::RunPCA(
    object = pbmc_qc,
    features = Seurat::VariableFeatures(object = pbmc_qc),
    npcs = 50L,
    verbose = FALSE,
    seed.use = 1L,
    assay = "RNA", #default at this stage
    layer = 'scale.data' # default
  )
pbmc_qc <- Seurat::FindNeighbors(
    object = pbmc_qc,
    dims = 1:10,
    k.param = 20, # default
    verbose = FALSE,
    l2.norm = FALSE
  )
pbmc_qc <- Seurat::FindClusters(
    object = pbmc_qc,
    resolution = 0.3,
    verbose = FALSE
  )
pbmc_qc <- Seurat::RunUMAP(
    object = pbmc_qc,
    umap.method = "uwot",
    dims = 1:10,
    verbose = FALSE
  )
Seurat::DimPlot(
      object = pbmc_qc,
      reduction = "umap"
    ) +
  theme_bw() +
  theme(
      aspect.ratio = 1
    )
```

## [4.9.] Map e.g., mitochondrial contribution to UMAP
```{r}
meta_qc <- pbmc_qc@meta.data %>%
  tibble::as_tibble(rownames = "cell")
umap_qc <- pbmc_qc@reductions$umap@cell.embeddings %>%
  tibble::as_tibble(rownames = "cell")

meta_qc_comb <- dplyr::left_join(
    x = umap_qc,
    y = meta_qc,
    by = "cell"
  )
cls <- meta_qc_comb %>%
  dplyr::group_by(seurat_clusters) %>%
  dplyr::summarise(
      pos_1 = base::mean(umap_1),
      pos_2 = base::mean(umap_2),
      .groups = "drop"
    )
ggplot2::ggplot(
      data = meta_qc_comb,
      mapping = aes(
        x = umap_1,
        y = umap_2,
        color = nFeature_RNA # percent.mt # nCount_RNA
      )
    ) +
  geom_point(
      size = 0.1
    ) +
  ggrepel::geom_label_repel(
      inherit.aes = FALSE,
      data = cls,
      mapping = aes(
          x = pos_1,
          y = pos_2,
          label = seurat_clusters
        )
    ) +
  scale_colour_gradientn(
      colours = cols
    ) +
  theme_bw() +
  theme(
      aspect.ratio = 1,
      axis.text = element_blank(),
      axis.ticks = element_blank()
    ) +
  guides(
    fill = "none",
    colour = guide_colourbar(
        label.position = "right",
        title = NULL,
        title.position = "left",
        title.theme = element_text(
            angle = 90,
            hjust = 0.5
          ),
        ticks = T,
        nbin = 100,
        barheight = 8,
        label = T,
        barwidth = 0.5
      )
    )
```

## [4.10.] Mean mitochondrial contribution per cluster
#### Cluster 7 & 8 might potentially be doublet clusters
```{r}
ggplot2::ggplot(
      data = meta_qc_comb,
      mapping = aes(
        x = seurat_clusters,
        y = nCount_RNA # percent.mt # nFeature_RNA
      )
    ) +
  geom_jitter(
      alpha = 0.1,
      height = 0,
      width = 0.3
    ) +
  geom_boxplot(
      outliers = FALSE,
      alpha = 0.5
    ) +
  theme_bw() +
  theme(
    aspect.ratio = 2
  )
```

## Question: Do cluster 7 & 8 consist of doublets or are these biologically meaningful cell types?
## (e.g., annotations, doublet detection)

# [5.] Marker genes -------------------------

## [5.0.] Identify all differential expressions
#### Check with 'base::range(pbmc_markers$avg_log2FC)' and 'base::range(pbmc_markers$p_val)'
```{r}
pbmc_markers <- Seurat::FindAllMarkers(
    object = pbmc_qc,
    only.pos = TRUE,
    assay = "RNA",
    slot = "data", # "scale.data"
    test.use = 'wilcox',
    verbose = FALSE,
    random.seed = 1L,
    return.thresh = 1, # no limitation
    logfc.threshold = -Inf # no limitation
  )
```

## [5.1.] Inspect markers
#### Matching of canonical cell type markers to identified unbiased marker genes
```{r}
pbmc_markers %>%
  dplyr::group_by(cluster) %>%
  dplyr::filter(
      p_val_adj < 1e-2 & avg_log2FC > 1
    ) %>%
  dplyr::summarise(
      nFeat_sigDE = dplyr::n()
    )

pbmc_markers %>%
  dplyr::group_by(cluster) %>%
  dplyr::filter(
      p_val_adj < 1e-2
    ) %>%
  dplyr::arrange(cluster, dplyr::desc(avg_log2FC)) %>%
  dplyr::filter(
      dplyr::row_number() %in% 1:10
    )
```

## [5.2.] Read out gene expression values from Seurat object
#### Default plotting via 'Seurat::FeaturePlot(pbmc_qc, features = "CD8A")'
#### Access to genes via 'SeuratObject::Features(x = pbmc_qc,layer = "data")'
```{r}
gene <- "CD8A"

Seurat::FetchData(
    object = pbmc_qc,
    vars = base::c(gene,"umap_1","umap_2"),
    cells = base::colnames(x = pbmc_qc),
    assay = "RNA",
    layer = "data"
  )

tibble::enframe(
  SeuratObject::LayerData(
      object = pbmc_qc,
      layer = "data",
      cells = base::colnames(x = pbmc_qc),
      features = base::rownames(x = pbmc_qc)
    )[gene,]
  )
```

#### Direct access
```{r}
m <- pbmc_qc@assays$RNA@layers$data
base::colnames(m) <- base::colnames(pbmc_qc)
base::rownames(m) <- base::rownames(pbmc_qc)
ge <- m[gene,]
ge_qc <- tibble::enframe(
    x = ge, name = "cell", value = gene
  )
umap_qc <- pbmc_qc@reductions$umap@cell.embeddings %>%
  tibble::as_tibble(rownames = "cell")
ge_comb <- dplyr::left_join(
    x = umap_qc, y = ge_qc, by = "cell"
  )
```

## [5.3.] Plot gene expression values onto the UMAP projection
```{r}
coef = 0.5
cols <- base::c(
    grDevices::colorRampPalette(
        base::c("#e7f0fa", "#c9e2f6", "#95cbee", "#0099dc", "#4ab04a", "#ffd73e")
      )(coef*100),
    grDevices::colorRampPalette(
      base::c("#eec73a", "#e29421", "#e29421", "#f05336","#ce472e"),
      bias=2
    )((1-coef)*100)
  )

ggplot2::ggplot(
      data = ge_comb,
      mapping = aes(
        x = umap_1,
        y = umap_2,
        color = CD8A
      )
    ) +
  geom_point(
      size = 0.1
    ) +
  scale_colour_gradientn(
      colours = cols
    ) +
  theme_bw() +
  theme(
      aspect.ratio = 1,
      axis.text = element_blank(),
      axis.ticks = element_blank()
    )
```

## [5.4.] Read in reference data
```{r}
ref <- base::readRDS(
    file = base::paste0(
      here::here("input_data/"),
      "pbmc_10k_v3.rds"
    )
  )
ref <- Seurat::UpdateSeuratObject(object = ref)
```

## [5.5.] Inspect reference dataset
```{r}
utils::str(ref)
ref@meta.data
Seurat::DimPlot(
      object = ref,
      reduction = "umap"
    ) +
  theme_bw() +
  theme(
      aspect.ratio = 1
    )
```

## [5.6.] Transfer annotations via identified anchors
```{r}
pbmc_anchors <- Seurat::FindTransferAnchors(
    reference = ref,
    query = pbmc_qc,
    dims = 1:50,
    reference.reduction = "pca",
    verbose = FALSE
  )
predictions <- Seurat::TransferData(
    anchorset = pbmc_anchors,
    refdata = ref$celltype,
    dims = 1:50,
    verbose = FALSE
  )
pbmc_qc <- Seurat::AddMetaData(
    object = pbmc_qc,
    metadata = predictions
  )
```

## [5.7.] Inspect & plot data
```{r}
pbmc_qc@meta.data
Seurat::DimPlot(
      object = pbmc_qc,
      reduction = "umap",
      group.by = "predicted.id"
    ) +
  theme_bw() +
  theme(
      aspect.ratio = 1
    )
```

## [5.8.] Label predicted IDs onto the UMAP dimension reduction
```{r}
pal <- base::c(
    "#3255A4", "#A4DBE8", "#8C8279",
    "#EA7600", "#F6BE00", "#28B463",
    "#AF7AC5", "#0E6655", "#0097A9",
    "#E03C31", "#B5BD00", "#500778",
    "#93272C", "#C6B0BC", "#8F993E",
    "#17202A", "#FF6F00", "#555025"
  )

meta_qc <- pbmc_qc@meta.data %>%
  tibble::as_tibble(rownames = "cell")
umap_qc <- pbmc_qc@reductions$umap@cell.embeddings %>%
  tibble::as_tibble(rownames = "cell")
meta_qc_comb <- dplyr::left_join(
    x = umap_qc,
    y = meta_qc,
    by = "cell"
  )

cls <- meta_qc_comb %>%
  dplyr::group_by(predicted.id) %>%
  dplyr::summarise(
      pos_1 = base::mean(umap_1),
      pos_2 = base::mean(umap_2),
      .groups = "drop"
    )

ggplot2::ggplot(
      data = meta_qc_comb,
      mapping = aes(
        x = umap_1,
        y = umap_2,
        color = predicted.id
      )
    ) +
  geom_point(
      size = 0.1
    ) +
  ggrepel::geom_label_repel(
      inherit.aes = FALSE,
      data = cls,
      mapping = aes(
          x = pos_1,
          y = pos_2,
          label = predicted.id
        ),
      box.padding = 1,
      max.overlaps = Inf
    ) +
  scale_colour_manual(
      values = pal
    ) +
  theme_bw() +
  theme(
      aspect.ratio = 1,
      axis.text = element_blank(),
      axis.ticks = element_blank()
    )
```

# [6.] Save & load data -------------------------

## [6.0.] Save Seurat Object pbmc_rna & the "nFeature_RNA"-cleaned version pbmc_qc
```{r}
# base::saveRDS(
#     object = pbmc_rna,
#     file = base::paste0(
#         here::here("output_data/"),
#         base::format(base::Sys.time(),"%Y%m%d"),
#         "_pbmc_RNA",
#         ".rds"
#       ),
#     compress = TRUE
#   )
```

```{r}
pbmc_rna <- base::list.files(
      path = here::here("output_data"),
      full.names = TRUE
    ) %>%
  stringr::str_subset("RNA.rds") %>%
  base::readRDS(
      file = .
    )
```

#### Older version without annotations 20241015_pbmc_RNA_qc.rds
```{r}
# base::saveRDS(
#     object = pbmc_qc,
#     file = base::paste0(
#         here::here("output_data/"),
#         base::format(base::Sys.time(),"%Y%m%d"),
#         "_pbmc_RNA_qc_annotated",
#         ".rds"
#       ),
#     compress = TRUE
#   )
```

```{r}
pbmc_qc <- base::list.files(
      path = here::here("output_data"),
      full.names = TRUE
    ) %>%
  stringr::str_subset("RNA_qc.rds") %>%
  base::readRDS(
      file = .
    )
```