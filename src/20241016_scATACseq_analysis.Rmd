---
title: "Novo Nordisk Applied Single Cell Analysis Course October 2024 - scATAC-seq analysis"
output:
  html_document: default
  pdf_document: default
date: "`r Sys.Date()`"
---

Modified from Signac Vignettes
Analyzing PBMC scATAC-seq: https://stuartlab.org/signac/articles/pbmc_vignette
Joint RNA and ATAC analysis: https://stuartlab.org/signac/articles/pbmc_multiomic
Motif analysis with Signac: https://stuartlab.org/signac/articles/motif_vignette

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## [0.] Prerequisites
### [0.1.] Load necessary packages
```{r message=FALSE, warning=FALSE}
library(Signac) # scATAC-seq analysis tools
library(Seurat) # scRNA-seq analysis tools
library(GenomicRanges) # Process ATAC peak regions
library(TFBSTools) # Transcription factor binding site analysis
library(ggplot2) # Visualization tools
library(patchwork) # combined multiple plots

library(EnsDb.Hsapiens.v86) # Human gene annotation database
library(BSgenome.Hsapiens.UCSC.hg38) # Human genome sequence database
library(JASPAR2020) # Transcription factor motif database
```


## [1.] Import data and create seurat/signac object
### [1.1.] Specify input files paths
#### Here, we import Cell Ranger ARC pre-processed results of PBMC multiome data.
#### For other 10x scATAC or multiome datasets, you can find these files under
#### outs/ directory for each sample.
#### See https://support.10xgenomics.com/single-cell-atac/software/pipelines/latest/output/overview (scATAC)
#### or https://www.10xgenomics.com/support/software/cell-ranger-arc/latest/analysis/outputs/understanding-output (multiome)
#### for more information of 10x Genomics Cell Ranger output
```{r}
count_matrix_dir <- "../input_data/filtered_feature_bc_matrix/"
fragments_path <- "../input_data/10k_PBMC_Multiome_nextgem_Chromium_X_atac_fragments.tsv.gz"
metadata_path <- "../input_data/10k_PBMC_Multiome_nextgem_Chromium_X_per_barcode_metrics.csv"
```

### [1.2.] Import count matrix
```{r message=FALSE, warning=FALSE}
pbmc_count_data <- Read10X(count_matrix_dir)
# Inspect count data
pbmc_count_data$Peaks[1:5,1:5]
```

### [1.3.] Import metadata
```{r message=FALSE, warning=FALSE}
pbmc_metadata <- read.csv(
  file = metadata_path,
  header = TRUE,
  row.names = 1
)
# Inspect metadata
pbmc_metadata[1:5,]
```

### [1.4.] Create seurat/signac object
```{r warning=FALSE}
# Create chromatinAssay object
chrom_assay <- CreateChromatinAssay(
  counts = pbmc_count_data$Peaks, ## Specify scATAC-seq
  sep = c(":", "-"),
  fragments = fragments_path,
  min.cells = 10, # include peaks detected in at least 10 cells
  min.features = 200 # include cells detecting more than 200 peaks
)

# Create seurat object from chromatinAssay object and integrate metadata
pbmc_atac <- CreateSeuratObject(
  counts = chrom_assay,
  assay = "peaks", # assay name
  meta.data = pbmc_metadata
)

# Remove peaks in non-standard chromosomes
peaks.keep <- seqnames(granges(pbmc_atac)) %in% standardChromosomes(granges(pbmc_atac))
pbmc_atac <- pbmc_atac[as.vector(peaks.keep), ]

# Add gene annotation information
annotation <- GetGRangesFromEnsDb(ensdb = EnsDb.Hsapiens.v86)
seqlevels(annotation) <- paste0('chr', seqlevels(annotation))
Annotation(pbmc_atac) <- annotation
```

### [1.5.] Data structure of seurat/signac object
#### See https://stuartlab.org/signac/articles/data_structures for more 
#### information about data structures and object interaction
```{r}
# Show peak and cell number
pbmc_atac

# Show peak x cell count matrix
pbmc_atac@assays$peaks$counts[1:5,1:5]

# Show peak information
granges(pbmc_atac)

# Show gene annotation
Annotation(pbmc_atac)
```


## [2.] Quality control (QC)
#### We follow signac pipeline to use following QC metrics:
#### i. Nucleosome signal: 
####    ratio of mononucleosomal to nucleosome-free fragments
#### ii. Transcriptional start site (TSS) enrichment score: 
####     ratio of fragments centered at the TSS to fragments in TSS-flanking 
####     regions (see https://www.encodeproject.org/data-standards/terms/)
#### iii. Total number of fragments in peaks
#### iv. Fraction of fragments in peaks
#### v. Ratio reads in genomic blacklist regions
### [2.1.] Compute quality control metrics
```{r}
# Compute nucleosome signal score per cell (It may take ~10 mins)
pbmc_atac <- NucleosomeSignal(object = pbmc_atac)

# Compute TSS enrichment score per cell (It may take ~10 mins)
pbmc_atac <- TSSEnrichment(object = pbmc_atac) 

# Add fraction of reads in peaks
pbmc_atac$pct_reads_in_peaks <- pbmc_atac$atac_peak_region_fragments / pbmc_atac$atac_fragments * 100

# Add blacklist ratio
pbmc_atac$blacklist_ratio <- FractionCountsInRegion(
  object = pbmc_atac, 
  assay = 'peaks',
  regions = blacklist_hg38_unified
)
```


### [2.2.] Determine threshold of QC metrics
#### The exact QC thresholds need to be adjusted based on your dataset. 
#### Consider plotting the distribution of each QC metric to accurately 
#### determine the appropriate thresholds. The primary objective is to 
#### exclude outliers while retaining the majority of cells.
```{r}
# Plot distribution of nucleosome signal
hist(pbmc_atac$nucleosome_signal,
     breaks = 20,
     main = "nucleosome_signal")
# Indicate threshold
abline(v = 1.5, # threshold
       col="red")

# Plot distribution of TSS enrichment score
hist(pbmc_atac$TSS.enrichment,
     main = "TSS.enrichment")
# Indicate threshold
abline(v = 4, # threshold
       col="red")

# Plot distribution of total number of fragments in peaks
hist(pbmc_atac$nCount_peaks,
     main = "nCount_peaks")
# Indicate threshold
abline(v = 10000, # threshold
       col="red")
abline(v = 100000, # threshold
       col="red")

# Plot distribution of fraction of fragments in peaks
hist(pbmc_atac$pct_reads_in_peaks,
     main = "pct_reads_in_peaks")
# Indicate threshold
abline(v = 40, # threshold
       col="red")

# Plot distribution of ratio reads in genomic blacklist regions
hist(pbmc_atac$blacklist_ratio,
     main = "blacklist_ratio")
# Indicate threshold
abline(v = 0.01, # threshold
       col="red")
```

### [2.3.] Filter high quality cells
#### Filter cells according to thresholds determined above
```{r}
pbmc_atac <- subset(
  x = pbmc_atac,
  subset = nucleosome_signal < 1.5 &
    TSS.enrichment > 4 &
    nCount_peaks > 10000 &
    nCount_peaks < 100000 &
    pct_reads_in_peaks > 40 &
    blacklist_ratio < 0.01 
)
```



## [3.] Dimensional reduction and clustering
### [3.1.]  Normalization and linear dimensional reduction
```{r}
# Perform term frequency-inverse document frequency (TF-IDF) normalization
pbmc_atac <- RunTFIDF(pbmc_atac)

# Feature selection
pbmc_atac <- FindTopFeatures(pbmc_atac, 
                             min.cutoff = 'q0') # Use all peaks here

# Perform singular value decomposition (SVD) for linear dimensional reduction
pbmc_atac <- RunSVD(pbmc_atac)

# Assess correlation between each LSI component and sequencing depth 
DepthCor(pbmc_atac, n = 30) 
# The first LSI component captures sequencing depth (technical variation)
# rather than biological variation.
```

### [3.2.] Non-linear dimension reduction with UMAP
```{r message=FALSE, warning=FALSE}
pbmc_atac <- RunUMAP(object = pbmc_atac, 
                     reduction = 'lsi', 
                     dims = 2:30) # Exclude the first LSI component 
```

### [3.3.] Clustering
```{r}
# Calculate nearest neighbors
pbmc_atac <- FindNeighbors(object = pbmc_atac, 
                           reduction = 'lsi', 
                           dims = 2:30) # Exclude the first LSI component

# Louvain clustering
pbmc_atac <- FindClusters(object = pbmc_atac,
                          resolution = 0.8) # higher resolution => more clusters

# Show clustering results on UMAP
DimPlot(object = pbmc_atac, 
        label = TRUE) + 
  NoLegend()
```

## [4.] Cell type annotation
### [4.1.] Quantify gene activity
#### Quantify the activity of each gene by summing the fragments intersecting 
#### the gene body and promoter (TSS 2 kb upstream region)
```{r warning=FALSE}
# Generate a gene activity matrix  (It may take ~8 mins)
gene.activities <- GeneActivity(pbmc_atac)

# Add the gene activity matrix to the Seurat object as a new assay
pbmc_atac[['RNA']] <- CreateAssayObject(counts = gene.activities)

# Normalize gene activity matrix
pbmc_atac <- NormalizeData(
  object = pbmc_atac,
  assay = 'RNA',
  normalization.method = 'LogNormalize',
  scale.factor = median(pbmc_atac$nCount_RNA)
)

# Show gene activity of marker genes on UMAP
DefaultAssay(pbmc_atac) <- 'RNA'
FeaturePlot(
  object = pbmc_atac,
  features = c('MS4A1', 'CD3D', 'LEF1', 'NKG7', 'TREM1', 'LYZ'),
  pt.size = 0.1,
  max.cutoff = 'q95',
  ncol = 2
)
```


### [4.2.] Transfer cell-type labels from scRNA-seq data
```{r warning=FALSE}
# Import seurat object of scRNA-seq
pbmc_rna <- readRDS("../output_data/20241015_pbmc_RNA_qc_annotated.rds")
pbmc_rna <- UpdateSeuratObject(pbmc_rna)

# Find anchors between scATAC gene activity and scRNA gene expression
transfer.anchors <- FindTransferAnchors(
  reference = pbmc_rna,
  query = pbmc_atac,
  reduction = 'cca'
)

# Transfer cell-type labels from scRNA-seq to scATAC-seq basing on anchors
predicted.labels <- TransferData(
  anchorset = transfer.anchors,
  refdata = pbmc_rna$predicted.id,
  weight.reduction = pbmc_atac[['lsi']],
  dims = 2:30 # Exclude the first LSI component
)
pbmc_atac <- AddMetaData(object = pbmc_atac, metadata = predicted.labels)

# Since we are using a scRNA+ATAC multiome dataset, we can determine the real 
# correspondence between scRNA and scATAC cells based on their barcodes. 
# Therefore, we project the cell types from scRNA-seq to scATAC-seq according 
# to real correspondence to assess the performance of the transfer algorithm.
pbmc_atac@meta.data[,"real.labels"] <- pbmc_atac@meta.data[colnames(pbmc_atac),"predicted.id"]
```


### [4.3.] Visualize cell type annotation
```{r}
plot1 <- DimPlot(
  object = pbmc_rna,
  group.by = 'predicted.id',
  label = TRUE,
  repel = TRUE) + 
  NoLegend() + 
  ggtitle('scRNA-seq')
plot1

plot2 <- DimPlot(
  object = pbmc_atac,
  group.by = 'predicted.id',
  label = TRUE,
  repel = TRUE) + NoLegend() + ggtitle('scATAC-seq, predicted labels')
plot2

plot3 <- DimPlot(
  object = pbmc_atac,
  group.by = 'real.labels',
  label = TRUE,
  repel = TRUE) + NoLegend() + ggtitle('scATAC-seq, real labels')
plot3
```
### [4.4.] Peak calling for each cell type
#### Cell Ranger aggregates all cell types together for peak calling, 
#### potentially overlooking cell-type specific peaks in rare cell type, 
#### such as pDCs. This oversight might affect the performance of differential
#### accessibility analysis.  We recommend  calling peaks for each cell type 
#### (see https://stuartlab.org/signac/articles/peak_calling for more 
#### information). However, this process requires installing python package 
#### macs2 and may take hours to compute. Therefore, we will not perform this 
#### step in today's course.



## [5.] Differential accessibility analysis
### [5.1.] Identify differentially accessible peaks between cell types
```{r}
Idents(pbmc_atac) <- pbmc_atac$predicted.id
DefaultAssay(pbmc_atac) <- 'peaks'
da_peaks <- FindMarkers(
  object = pbmc_atac,
  ident.1 = "CD4 Naive",
  ident.2 = "CD14+ Monocytes",
  test.use = 'wilcox', # Wilcoxon Rank Sum test
  min.pct = 0.1 # peaks detected in 10% cells in either of the two populations
)
head(da_peaks)
```

### [5.2.] Visualize differential peak
```{r}
# Show peak accessibility using violin plot
plot1 <- VlnPlot(
  object = pbmc_atac,
  features = rownames(da_peaks)[1], # Specify peak name
  pt.size = 0.1,
  idents = c("CD4 Naive", "CD14+ Monocytes")
)
plot1

# Show peak accessibility on UMAP
plot2 <- FeaturePlot(
  object = pbmc_atac,
  features = rownames(da_peaks)[1],  # Specify peak name
  pt.size = 0.1
)
plot2
```

### [5.3.] Annotate differential peaks to closest genes
```{r}
# Selecte differential peaks, log2(fold change) > 3
open_cd4naive <- rownames(da_peaks[da_peaks$avg_log2FC > 3, ])
open_cd14mono <- rownames(da_peaks[da_peaks$avg_log2FC < -3, ])

# Find closest genes
closest_genes_cd4naive <- ClosestFeature(pbmc_atac, regions = open_cd4naive)
closest_genes_cd14mono <- ClosestFeature(pbmc_atac, regions = open_cd14mono)

# Show differential peaks and closest genes
head(closest_genes_cd4naive)
head(closest_genes_cd14mono)
```

### [5.4.] Visualize genomic region
```{r}
# Select highlight regions
regions_highlight <- subsetByOverlaps(StringToGRanges(open_cd14mono), 
                                      LookupGeneCoords(pbmc_atac, "LYZ"))

# Plot coverage
CoveragePlot(
  object = pbmc_atac,
  region = "LYZ",
  region.highlight = regions_highlight,
  extend.upstream = 1000,
  extend.downstream = 5000
)
```


## [6.] Motif analysis
### [6.1.] Load Motif information from JASPAR database
```{r warning=FALSE}
# Extract TF motif from JASPAR database
pfm <- getMatrixSet(
  x = JASPAR2020,
  opts = list(collection = "CORE", 
              tax_group = 'vertebrates', 
              all_versions = FALSE)
)

# Add motif information to the seurat object
pbmc_atac <- AddMotifs(
  object = pbmc_atac,
  genome = BSgenome.Hsapiens.UCSC.hg38,
  pfm = pfm
)
```

### [6.2.] Identify motifs enriched in differential peaks
```{r}
# find enriched motifs in differential Peaks
DefaultAssay(pbmc_atac) <- 'peaks'
enriched.motifs <- FindMotifs(
  object = pbmc_atac,
  features = open_cd4naive # differential peaks identified in [5.3.]
)

# Plot enriched Motifs
MotifPlot(
  object = pbmc_atac,
  motifs = head(rownames(enriched.motifs))
)
```

### [6.3.] Computing motif activities with ChromVAR
```{r warning=FALSE}
# Run ChromVAR
pbmc_atac <- RunChromVAR(object = pbmc_atac, 
                         genome = BSgenome.Hsapiens.UCSC.hg38)
DefaultAssay(pbmc_atac) <- 'chromvar'

# Visualize motif activity of Mef2c on UMAP
p1 <- DimPlot(pbmc_atac, label = TRUE, pt.size = 0.1) + NoLegend()
p2 <- FeaturePlot(
  object = pbmc_atac,
  features = "MA0497.1", # Mef2c
  min.cutoff = 'q10',
  max.cutoff = 'q90',
  pt.size = 0.1
)
p1 + p2
```

### [6.4.] Identify differentially activity of motifs between cell types
```{r}
differential.activity <- FindMarkers(
  object = pbmc_atac,
  ident.1 = "CD4 Naive",
  ident.2 = "CD14+ Monocytes",
  only.pos = TRUE,
  mean.fxn = rowMeans,
  fc.name = "avg_diff"
)

# Visualize motifs with differentially activity
MotifPlot(
  object = pbmc_atac,
  motifs = head(rownames(differential.activity)),
  assay = 'peaks'
)
```

## [7.] Save seurat object
```{r save-results}
saveRDS(pbmc_atac, "../output_data/pbmc.ATAC.rds")
```
```



